#
model.ppm <- function(param,model=model,clust=clust,param2=NULL) {
A <- as.im(model,clust$win,param=param,param2=param2)
ppm(clust, ~offset(log(B)), covariates = list(B=A))
}
#
# draw.model (Overplots model ellipses on an image of )
# ------------------------------------------------------
# The inputs are the "param" and "param2" vectors (described in multi.model),
# the size of the ellipse in core radii, the color of the ellipse, and the
# width of the ellipse.
# There is no output. This function causes ellipses to be plotted in the graphics
# window.
# Usage> draw.ellipse(param=param,param2=param2,size=1,border=2,lwd=2)
#
draw.model <- function(param=param,param2=param2,size=1,border=2,lwd=2) {
n_models <- param2[[1]]
p1 <- 1
p2 <- 2
n1 <- length(param)
n2 <- length(param2)
i <- 1
while (i < n_models+1) {
par1 <- param[p1:n1]
par2 <- param2[p2:n2]
model <- par2[[1]]
n_param <- par2[[2]]
param_new=NULL
if (n_param > 0) { param_new=par1[1:n_param] }
scale <- 1.0
if (i > 1) {
scale <- 10.0^(par1[[n_param+1]])
p1 <- p1 + 1
}
if (n_param == 5) {
draw.ellipse(param_new[1],param_new[2],a=param_new[3]*size,b=param_new[3]*param_new[5]*size,
angle=param_new[4]*180.0/pi %% 360.0,deg=T,border=border,lwd=lwd)
}
if (n_param == 3) {
draw.ellipse(param_new[1],param_new[2],a=param_new[3]*size,b=param_new[3]*size,angle=0.0,border=border,lwd=lwd)
}
p2 <- p2 + 2
p1 <- p1 + n_param
i <- i+1
}
# No output
}
#
# param2ellipse (Converts an array of parameters into an R data frame)
# -------------------------------------------------------------------
# The input is an array of parameters in the variable "param" as described
# for the function multi.model. The assumed model form is
# for a model with "param2" of c(<n+1>,model.ell,5, ... , model.ell,5,model.const,0)
# The output is a data.frame object with columns, x, y, core, theta, b, and mix.
# Usage> ellipse <- param2ellipse(param)
#
param2ellipse <-function(param){
n <- length(param)/6 # i.e. six parameters for ellipses, minus one for the first mix, plus one for constant component
ellipsoid <- data.frame(x=rep(NA,n),y=rep(NA,n),core=rep(NA,n),theta=rep(NA,n),b=rep(NA,n),mix=rep(NA,n))
adjust <- 0 # compensate for missing mix[1]
for (i in 1:n){
ellipsoid[i,1] <- param[6*(i-1)+1-adjust]
ellipsoid[i,2] <- param[6*(i-1)+2-adjust]
ellipsoid[i,3] <- param[6*(i-1)+3-adjust]
ellipsoid[i,4] <- param[6*(i-1)+4-adjust]
ellipsoid[i,5] <- param[6*(i-1)+5-adjust]
if (i > 1) {ellipsoid[i,6] <- param[6*(i-1)+6-adjust]}
if (i == 1) {ellipsoid[i,6] <- 0.0}
adjust <- 1
}
ellipsoid
}
#
# ellipse2param (Converts an R data frame into an array of parameters)
# -------------------------------------------------------------------
# The input is a data.frame object with columns, x, y, core, theta, b,
# and mix, describing a collection of ellipsoids. The variable
# "const_mix" is the log mixing parameter for the constant component.
# The output is an array of parameters in the format of the "param" argument
# to the function multi.model. The assciated "param2" variable for this
# "param" array has the form c(<n+1>,model.ell,5, ... , model.ell,5,model.const,0)
# Usage> param <- ellipse2param(ellipse)
#
ellipse2param <-function(ellipse,const_mix=-1.5){
param <- c(t(as.matrix(ellipse)))
if (param[6] != 0.0) {print("Error!")}
param <- param[-6]
c(param,const_mix)
}
#
# mask.freeze (optimization procedure will only allow certain parameters to be fit by optim, while the others stay fixed)
# -----------------------------------------------------------------------------------------------------------------------
# The input is the "param" array assuming the form for "param2" of c(<n+1>,model.ell,5, ... , model.ell,5,model.const,0),
# a vecor of 1s and 0s "mask" which indicates which parameters in "param" should be fit (1) or frozen (0), and the ppp object
# clust.
# The output is an optimized parameter array.
# Usage> param <- mask.freeze(param,mask.adjust_positions(n),clust=clust)
#
mask.freeze <- function(param_input,mask,clust=clust){
ind_masked <- which(mask == 0)
ind_unmasked <- which(mask == 1)
ocf <- optim(param_input[ind_unmasked],model.lik,model=mask.model,clust=clust,param2=c(param_input[ind_masked],ind_masked))
param_out <- param_input
param_out[ind_unmasked] <- ocf$par
param_out
}
#
# mask.model (model that is passed to optim by the mask.freeze function)
# ----------------------------------------------------------------------
# The input is the same as other models, x and y coordinates, and the model "param" parameters, and
# the model "param2" description.
# The output is the value of the model at the position (x,y).
# Usage> ocf <- optim(param_input[ind_unmasked],model.lik,model=mask.model,clust=clust,param2=c(param_input[ind_masked],ind_masked))
#
mask.model <- function(x1,y1,param=NULL,param2=param2) {
n_masked <- length(param2)/2
n_unmasked <- length(param)
n_par <- n_masked + n_unmasked
mask <- rep(1,n_par)
ind_masked=round(param2[(n_masked+1):(n_masked*2)])
mask[ind_masked] <- 0
ind_unmasked=which(mask == 1)
param_input <- rep(0.0,n_par)
param_input[ind_masked] <- param2[1:n_masked]
param_input[ind_unmasked] <- param
n <- length(param_input)/6
param_models <- c(n+1)
for (i in 1:n) { param_models=c(param_models,ell.model,5) }
param_models <- c(param_models,const.model,0)
multi.model(x1,y1,param=param_input,param2=param_models)
}
#
# mask.adjust_positions (creats an array of 1s and 0s for freezeing and thawing parameters in mask.freeze)
# ----------------------------------------------------------------------
# The input is an integer "n" corresponding to the number of ellipsoids in a finite mixture model described by the
# "param2" variable c(<n+1>,model.ell,5, ... , model.ell,5,model.const,0).
# The output is an array of 1s and 0s with length 6*n. Position and mixing parameters are thawed.
# Usage> param <- mask.freeze(param,mask.adjust_positions(n),clust=clust)
#
mask.adjust_positions <- function(n) {
mask <- rep(0,6*n)
mask[1:2] <- 1
if (n > 1) {
indx <- (1:(n-1))*6
indy <- 1+(1:(n-1))*6
indmix <- 5+(1:(n-1))*6
mask[indx] <- 1
mask[indy] <- 1
mask[indmix] <- 1
}
mask
}
#
# mask.adjust_rotations (creats an array of 1s and 0s for freezeing and thawing parameters in mask.freeze)
# ----------------------------------------------------------------------
# The input is an integer "n" corresponding to the number of ellipsoids in a finite mixture model described by the
# "param2" variable c(<n+1>,model.ell,5, ... , model.ell,5,model.const,0).
# The output is an array of 1s and 0s with length 6*n. Rotation parameters are thawed.
# Usage> param <- mask.freeze(param,mask.adjust_positions(n),clust=clust)
#
mask.adjust_rotations <- function(n) {
mask <- rep(0,6*n)
mask[4] <- 1
if (n > 1) {
indrot <- (1:(n-1))*6+3
mask[indrot] <- 1
}
mask
}
#
# mask.adjust_size (creats an array of 1s and 0s for freezeing and thawing parameters in mask.freeze)
# ----------------------------------------------------------------------
# The input is an integer "n" corresponding to the number of ellipsoids in a finite mixture model described by the
# "param2" variable c(<n+1>,model.ell,5, ... , model.ell,5,model.const,0).
# The output is an array of 1s and 0s with length 6*n. Core radius and mixing parameters are thawed.
# Usage> param <- mask.freeze(param,mask.adjust_positions(n),clust=clust)
#
mask.adjust_size <- function(n) {
mask <- rep(0,6*n)
mask[3] <- 1
if (n > 1) {
indcore <- (1:(n-1))*6+2
indmix <- 5+(1:(n-1))*6
mask[indcore] <- 1
mask[indmix] <- 1
}
mask
}
#
# mask.adjust_shape (creats an array of 1s and 0s for freezeing and thawing parameters in mask.freeze)
# ----------------------------------------------------------------------
# The input is an integer "n" corresponding to the number of ellipsoids in a finite mixture model described by the
# "param2" variable c(<n+1>,model.ell,5, ... , model.ell,5,model.const,0).
# The output is an array of 1s and 0s with length 6*n. Core radius and axis ratio parameters are thawed.
# Usage> param <- mask.freeze(param,mask.adjust_positions(n),clust=clust)
#
mask.adjust_shape <- function(n) {
mask <- rep(0,6*n)
mask[3] <- 1
mask[5] <- 1
if (n > 1) {
indcore <- (1:(n-1))*6+2
indb <- (1:(n-1))*6+4
indmix <- 5+(1:(n-1))*6
mask[indcore] <- 1
mask[indb] <- 1
mask[indmix] <- 1
}
mask
}
#
# mask.adjust_mix (creats an array of 1s and 0s for freezeing and thawing parameters in mask.freeze)
# ----------------------------------------------------------------------
# The input is an integer "n" corresponding to the number of ellipsoids in a finite mixture model described by the
# "param2" variable c(<n+1>,model.ell,5, ... , model.ell,5,model.const,0).
# The output is an array of 1s and 0s with length 6*n. Mixture coefficient are thawed.
# Usage> param <- mask.freeze(param,mask.adjust_positions(n),clust=clust)
#
mask.adjust_mix <- function(n) {
mask <- rep(0,6*n)
if (n > 1) {
indmix <- 5+(1:(n-1))*6
mask[indmix] <- 1
}
mask[length(mask)] <- 1
mask
}
#
# ds9.colors (creates an intensity colormap mimicking the ds9 hsv scheme)
# ----------------------------------------------------------------------
# The input "n" is the number of steps in the map.
# The output is an array of hexadecimal RGB colors.
# Usage> image(t(volcano)[ncol(volcano):1,],col=ds9.colors(512))
#
ds9.colors <- function(n){
x <- (0:n)*1.0/n
h <- (270.0/360.0-x+1.0) %% 1.0
s <- 4.0*x*(1.0-x)
v <- x^0.33
color <- hsv(h=h,s=s,v=v)
color
}
#
# american.colors (creates an intensity colormap with white as the middle color)
# ----------------------------------------------------------------------
# The input "n" is the number of steps in the map.
# The output is an array of hexadecimal RGB colors.
# Usage> image(t(volcano)[ncol(volcano):1,],col=american.colors(512))
#
american.colors <- function(n){
x <- (0:n)*1.0/n
h <- round(1-x)*0.667
v <- pmin(1.0,(1.1-abs(1-2*x))*3)
s <- abs(2*x-1)
hsv(h=h,s=s,v=v)
}
#
# ad2xy.tangent (Gnomonic (Tangent Plane) Projection)
# ---------------------------------------------------
# Input: Vector of RAs (alpha), vector of DECs (delta), center
# RA and Dec (alpha0,delta0), and conversion from degrees to pixel
# All units are in decimal degrees.
# The output is a vector of projected (x,y) coordinates
# Usage> ad2xy.tangent(alpha,delta,alpha0,delta0,scale=60.0)
#
ad2xy.tangent <- function(alpha,delta,alpha0,delta0,scale=1.0){
alph <- as.double(alpha)*pi/180.0
delt <- as.double(delta)*pi/180.0
alph0 <- as.double(alpha0)*pi/180.0
delt0 <- as.double(delta0)*pi/180.0
A <- cos(delt) * cos(alph - alph0)
F <- scale * (180.0/pi) / (sin(delt0) * sin(delt) + A*cos(delt0))
x <- -F * cos(delt) * sin(alph - alph0) # SAMPLE
y <- F * (cos(delt0) * sin(delt) - A*sin(delt0)) # LINE
data.frame(x=x,y=y)
}
#
# xy2ad.tangent (Inverse of ad2xy.tangent)
# ---------------------------------------------------
# Input: Vector of x's, vector of y's, center
# RA and Dec (alpha0,delta0), and conversion from degrees to pixel
# All units are in decimal degrees.
# The output is a vector of projected (x,y) coordinates
# Usage> ad2xy.tangent(x,y,alpha0,delta0,scale=60.0)
#
xy2ad.tangent <- function(x,y,alpha0,delta0,scale=1.0){
x2 = x/(scale*180.0/pi)
y2 = -y/(scale*180.0/pi)
D = arctan(sqrt(x2^2+y2^2))
B = arctan(-x2/y2)
XX = sin(delta0)*sin(D)*cos(B) + cos(delta0)*cos(D)
YY = sin(D)*sin(B)
alpha = alpha0 + arctan(YY/XX)
delta = arcsin(sin(delta0)*cos(D) - cos(delta0)*sin(D)*cos(B))
data.frame(alpha=alpha,delta=delta)
}
#
# star.ppp (Creates a spatstat point process object from machine readable tables)
# -------------------------------------------------------------------------------
# The input is the name of the target region and the distance to the target.
# The output is a "ppp" object.
# Usage> clust <- star.ppp(target='w40',distance=0.50)
#
star.ppp <- function(target=target,distance=distance){
# conversion between degrees and parsecs
deg2pc = distance*1000.0*3600.0/206264.8
# create window
dat.win <- read.table('fov_mrt.txt',skip=18,col.names=c('target','ra','dec','type'))
ra0 <- dat.win[which(dat.win$target == target & dat.win$type == "origin"),2]
de0 <- dat.win[which(dat.win$target == target & dat.win$type == "origin"),3]
ra.win <- dat.win[which(dat.win$target == target & dat.win$type == "vertex"),2]
de.win <- dat.win[which(dat.win$target == target & dat.win$type == "vertex"),3]
xy.win <- ad2xy.tangent(ra.win,de.win,ra0,de0,scale=deg2pc)
win <- owin(poly = xy.win)
# get points
dat.stars <- read.table('stars_mrt.txt',skip=18,col.names=c('target','desig','ra','dec'))
ra.stars <- dat.stars[which(dat.stars$target == target),3]
de.stars <- dat.stars[which(dat.stars$target == target),4]
xy.stars <- ad2xy.tangent(ra.stars,de.stars,ra0,de0,scale=deg2pc)
# output spatstat ppp object
ppp(xy.stars$x,xy.stars$y,window=win)
}
#
# make.fig2 (Plotting commands to produce Figure 2)
# -------------------------------------------------
# Input: the param, param2, ppp object, pixelated surface density image, and min and max colorscale values
# Output: There is no output. Produces image in graphics device.
# Usage> make.fig2(param, param2, clust=clust, image=density, min.im=5.0,max.im=20000.0)
#
make.fig2 <- function(param,param2,clust=clust,image=image, min.im=min.im,max.im=max.im){
im2 <- eval.im(5.0*(density < min.im) + density*(density > min.im)) # To make the plot look nice.
plot(clust$window,main="Adaptive Surface Density",lwd=10)
plot(eval.im(log10(im2)),add=T,col=ds9.colors(1000),transparent.color='transparent',zlim=log10(c(min.im,max.im)))
draw.model(param,param2,size=1)
plot(clust$window,add=T,lwd=10)
}
#
# make.fig4 (Plotting commands to produce Figure 4 (left panel))
# --------------------------------------------------------------
# Input: param, model, ppp object, param2, smoothing bandwith
# Output: There is no output. Produces an image in graphics device.
# Usage> make.fig4(param,model=multi.model,clust=clust,param2=param2,bandwidth=0.38)
#
make.fig4 <- function(param,model=model,clust=clust,param2=param2, bandwidth=bandwidth){
mlfit <- suppressWarnings(
model.ppm(param,model=multi.model,clust=clust,param2=param2))
dd <- diagnose.ppm(mlfit,which="smooth",sigma=bandwidth,plot.smooth='image',main='',plot.it=FALSE)
ddmax <- max(c(max(dd$smooth$Z),-min(dd$smooth$Z)))
plot(dd$smooth$Z,box=FALSE,main='',zlim=c(-ddmax,ddmax),col=american.colors(512),
ribsep=0.02,ribside='right',ribargs=)
draw.model(param,param2,size=1,border=1)
plot(clust$window,add=T,lwd=10)
}
make.fig4
ell.model(0,1,param=c(0.0, 0.0, 1.0, pi/4, 0.5))
make.fig4(param,model=multi.model,clust=clust,param2=param2,bandwidth=0.38)
const.model(0,1,param2=NULL)
multi.model(0,1,param2=c(0.0, 0.0, 1.0, pi/4, 0.5, 2.0, 2.0, 0.5, pi/6, 1.0, 0.0),
param2=c(2,ell.model,5,ell.model,5))
const.model(0,1,param2=NULL)
multi.model(0,1,param=c(0.0, 0.0, 1.0, pi/4, 0.5, 2.0, 2.0, 0.5, pi/6, 1.0, 0.0),
param2=c(2,ell.model,5,ell.model,5))
loglik <- -model.lik(param,model=model.multi,clust=clust,param2=param2)
loglik <- -model.lik(param,model=multi.model,clust=clust,param2=param2)
model.lik <- function(param,model=model,clust=clust,param2=NULL) {
A <- as.im(model,clust$win,param=param,param2=param2)
norm <- integral.im(A)
result <- sum(log(model(clust$x,clust$y,param=param,param2=param2)/norm*clust$n))-clust$n
-result
}
loglik <- -model.lik(param,model=multi.model,clust=clust,param2=param2)
clust <- star.ppp(target='w40',distance=0.50)
clust
plot(clust)
dat.win <- read.table('fov_mrt.txt',skip=18,col.names=c('target','ra','dec','type'))
dat.win
require(dplyr)
require(magrittr)
library(factoextra)
require(mclust)
require('spatstat') ; library(spatstat)
require(VBmix)
require(MixAll)
Star_dat <- read.csv("candidate_0_GDR2.csv",header = TRUE) %>%
#select(.,-"proba") %>%
filter(.,phot_g_mean_mag < 20)  %>%
na.omit() %>% select(c("ra","dec","parallax","pmra","pmdec","phot_g_mean_mag",
"phot_bp_mean_mag","phot_rp_mean_mag")) %>%
mutate(.,bp.rp = phot_bp_mean_mag - phot_rp_mean_mag)
setwd("~/Documents/GitHub/COIN_star_cluster")
require(dplyr)
require(magrittr)
library(factoextra)
require(mclust)
require('spatstat') ; library(spatstat)
require(VBmix)
require(MixAll)
Star_dat <- read.csv("candidate_0_GDR2.csv",header = TRUE) %>%
#select(.,-"proba") %>%
filter(.,phot_g_mean_mag < 20)  %>%
na.omit() %>% select(c("ra","dec","parallax","pmra","pmdec","phot_g_mean_mag",
"phot_bp_mean_mag","phot_rp_mean_mag")) %>%
mutate(.,bp.rp = phot_bp_mean_mag - phot_rp_mean_mag)
features <- c("pmra","pmdec")
Star_CL <- Mclust(temp_dat[,features],G=1:20)
Star_labels <- Star_CL$classification
temp_dat$labels <- as.factor(Star_labels)
temp_dat <- temp_dat[Star_CL$classification %in%surv,]
ggplot(temp_dat,aes(x=pmra,y=pmdec,group=labels,color=labels,alpha=0.1)) +
# geom_point() +
facet_wrap(.~labels) +
theme_bw() + theme(legend.position =  "none") +
geom_density2d()
ggplot(temp_dat,aes(x=ra,y=dec,group=labels,color=labels,alpha=0.1)) +
#  geom_point() +
facet_wrap(.~labels) +
theme_bw() + theme(legend.position =  "none") +
geom_density2d()
ggplot(temp_dat,aes(x= bp.rp,y=phot_g_mean_mag,group=labels,color = parallax, alpha=0.1)) +
geom_point(size=0.2) + facet_wrap(.~labels) +
theme_bw() + theme() +
#  geom_density2d() +
scale_y_reverse() + scale_color_viridis_c()
ggplot(Star_dat,aes(x= bp.rp,y=phot_g_mean_mag)) +
geom_point(size=0.2) +
theme_bw() + theme() +
#  geom_density2d() +
scale_y_reverse() + scale_color_viridis_c()
ggplot(temp_dat,aes(x=pmra,y=pmdec,group=labels,color=labels,alpha=0.1)) +
# geom_point() +
#  facet_wrap(.~labels) +
theme_bw() + theme(legend.position =  "none") +
geom_density2d()
ggplot(temp_dat,aes(x=pmra,y=pmdec,group=labels,color=labels,alpha=0.1)) +
geom_point() +
#  facet_wrap(.~labels) +
theme_bw() + theme(legend.position =  "none") +
geom_density2d()
Star_labels <- Star_CL$classification
Star_dat$labels <- as.factor(Star_labels)
Star_CL <- Mclust(temp_dat[,features],G=1:20)
Star_labels <- Star_CL$classification
Star_dat$labels <- as.factor(Star_labels)
Star_CL
Star_labels <- Star_CL$classification
Star_labels
Star_dat <- read.csv("candidate_0_GDR2.csv",header = TRUE) %>%
#select(.,-"proba") %>%
filter(.,phot_g_mean_mag < 20)  %>%
na.omit() %>% select(c("ra","dec","parallax","pmra","pmdec","phot_g_mean_mag",
"phot_bp_mean_mag","phot_rp_mean_mag")) %>%
mutate(.,bp.rp = phot_bp_mean_mag - phot_rp_mean_mag)
features <- c("pmra","pmdec")
Star_CL <- Mclust(temp_dat[,features],G=1:20)
Star_labels <- Star_CL$classification
Star_dat$labels <- as.factor(Star_labels)
setwd("~/Documents/GitHub/COIN_star_cluster")
Star_dat <- read.csv("candidate_0_GDR2.csv",header = TRUE) %>%
#select(.,-"proba") %>%
filter(.,phot_g_mean_mag < 20)  %>%
na.omit() %>% select(c("ra","dec","parallax","pmra","pmdec","phot_g_mean_mag",
"phot_bp_mean_mag","phot_rp_mean_mag")) %>%
mutate(.,bp.rp = phot_bp_mean_mag - phot_rp_mean_mag)
features <- c("pmra","pmdec")
Star_CL <- Mclust(temp_dat[,features],G=1:20)
Star_labels <- Star_CL$classification
Star_dat$labels <- as.factor(Star_labels)
Star_CL <- Mclust(Star_dat[,features],G=1:20)
Star_labels <- Star_CL$classification
Star_dat$labels <- as.factor(Star_labels)
ggplot(Star_dat,aes(x=pmra,y=pmdec,group=labels,color=labels,alpha=0.1)) +
# geom_point() +
facet_wrap(.~labels) +
theme_bw() + theme(legend.position =  "none") +
geom_density2d()
ggplot(Star_dat,aes(x=ra,y=dec,group=labels,color=labels,alpha=0.1)) +
#  geom_point() +
facet_wrap(.~labels) +
theme_bw() + theme(legend.position =  "none") +
geom_density2d()
ggplot(Star_dat,aes(x= bp.rp,y=phot_g_mean_mag,group=labels,color = parallax, alpha=0.1)) +
geom_point(size=0.2) + facet_wrap(.~labels) +
theme_bw() + theme() +
#  geom_density2d() +
scale_y_reverse() + scale_color_viridis_c()
ggplot(Star_dat,aes(x=pmra,y=pmdec,group=labels,color=labels,alpha=0.1)) +
geom_point() +
#  facet_wrap(.~labels) +
theme_bw() + theme(legend.position =  "none") +
geom_density2d()
Star_dat <- read.csv("output_final.csv",header = TRUE) %>%
#select(.,-"proba") %>%
filter(.,phot_g_mean_mag < 20)  %>%
na.omit() %>% select(c("ra","dec","parallax","pmra","pmdec","phot_g_mean_mag",
"phot_bp_mean_mag","phot_rp_mean_mag")) %>%
mutate(.,bp.rp = phot_bp_mean_mag - phot_rp_mean_mag)
Star_dat
Star_dat <- read.csv("output_final.csv",header = TRUE)
Star_dat
Van_Gogh <- c("#263C8B","#4E74A6", "#BDBF78", "#BFA524", "#2E231F")
colpal<-colorRampPalette(Van_Gogh)(100)
cutColor <- 100
require(classInt)
Star_dat$patch
Star_dat$X
Star_dat$Cluster_ID
Star_dat$PMRA.DIS
Star_dat$patch
Star_dat$l
Star_dat$b
plot(Star_dat$l,Star_dat$b)
Star_dat
